

Digitalisierung

Technische Grundbegriffe

Software

IDE

Algorithmus

Testautomatisierung

Versionierung

Continuous Integration

Continuous Deployment

Deployment

Server

Virtualisierung

Container

Kubernetes

Cloud

Interfaces

Datenaustauschformate

Internet

Datenbank

Software Architektur

Daten

Künstliche Intelligenz

Von der Idee zur Umsetzung

Jedes Digitalisierungsprojekt startet mit einer Idee. Startups versuchen aktuelle Branchen mit disruptiven Ideen zu übernehmen. Amazon hat den Handel übernommen, Booking.com und AirBnB das Hotelgewerbe, Uber das Taxigewerbe und Spotify die Musikbranche. Diese Unternehmen haben sich eine Branche ausgesucht und übernommen, durch die Möglichkeiten der Digitalisierung. Alle diese Firmen sind Softwareentwicklungsunternehmen.

Eine Idee kann eine neue weltbewegende disruptive Innovation sein oder auch nur das Digitalisieren eines kleinen Prozesses der in Ihrem Unternehmen noch manuell durchgeführt wird. Z.B. anstatt Rechnungen in Excel oder Word zu schreiben, kaufen Sie sich eine Rechnungschreibungssoftware. Oder Sie können sich überlegen wie Sie Ihre Produkte um digitale Services ergänzen. Wenn Sie gar keine Idee haben, schauen Sie welche Prozesse in Ihrem Unternehmen mit Excel abgebildet sind. Das ist immer ein guter Ansatzpunkt für Digitalisierung. Wichtig ist, dass Sie sich nicht übernehmen. Suchen Sie sich am Anfang ein kleines Projekt heraus, dass Ihnen die Schwachstellen in Ihrem Unternehmen aufzeigt die die Digitalisierung verhindert:

- Haben Sie die richtige Qualifizierung Ihrer Mitarbeiter
- Sind Ihre Mitarbeiter und Leiter gewillt sich zu verändern 
- Gibt es IT Restriktionen die es Software Entwicklern schwer macht Themen einfach und effektiv umzusetzen.
- Ist Ihre HR in der Lage schnell und unkompliziert gute IT-Experten einzustellen. Die sind schneller weg als sie schauen. 

Schauen Sie sich das erste kleine Projekt an und lernen Sie aus dessen Fehlern. Und erst wenn Sie diese Probleme ausgemerzt haben, machen Sie ein nächstes Projekt.

Eine wichtige Lektion in der Digitalisierung, denken Sie immer in Schritten. Fangen Sie klein an und wenn Sie einen ersten Schritt erfolgreich abgeschlossen haben, gehen Sie den nächsten. Das muss ein Mantra werden in jedem Digitalisierungsprojekt.

Idee konkretisieren

Wenn Sie eine Idee haben welches Thema oder welchen Prozess sie digitalisieren wollen, versuchen Sie diese Idee zu konkretisieren. Seien Sie vor allem im Ergebnis offen. Vielleicht ist der aktuelle Prozess suboptimal, vielleicht haben Ihre Mitarbeiter gute Ideen das Thema noch einfacher und besser zu machen, vielleicht wird der Prozess gar nicht mehr benötigt. Das Nutzen von kreativen Methoden ist sinnvoll. Von einfachen „drüber-nachdenken“, Brainstorming, Reizwortanalyse bis hin zu einem Design Thinking Workshop ist alles möglich. 

Bei ersten Projekten kann es sein, dass ein Business Value zu rechnen keinen Sinn macht. Sie müssen Wissen aufbauen, sie werden Fehler machen und müssen aus diesen lernen. Das dauert Zeit und kostet Geld. Vor allem sollten Sie immer überlegen ob das Entwickeln von eigener Software notwendig ist. Wenn man z.B. eine Rechnungsschreibung oder ein Projektmanagementtool einführen möchte, weil man vorher mit Word oder Excel geplant und abgerechnet hat, macht es Sinn sich diese von einem Hersteller zu kaufen.

Eine eigene Software wie eine App oder eine Webseite zu entwickeln oder das Sammeln und Analysieren von Daten kann trotzdem Sinn machen da Unternehmen oft spezielle Prozesse haben die von Standardsoftware nicht abgebildet werden. Allerdings werden Sie diese Software so schnell nicht wieder los. Sie müssen die Software entwickeln und betreiben. Sie benötigen Support falls es Probleme gibt und Sie werden neue Ideen und Anforderungen nachträglich einbauen. Seien Sie sich darüber im Klaren, dass Software Projekte auch scheitern können und Sie viel Geld investieren bei dem Sie keinen Mehrwert generieren. 

Wenn man jetzt eine eigene Software schreiben möchte, weil es keine Lösung am Markt gibt oder weil diese nicht auf die aktuellen Prozesse passen, müssen auf alle Fälle folgende Punkte betrachtet werden auf die wir alle näher eingehen werden:

- Erfassen der Anforderungen
- Zusammenstellen eines Teams, intern oder extern
- Entwickeln der App auf Basis der Anforderungen
- Rollout oder Deployment
- Betrieb mit Bugfixing und Hinzufügen neuer Anforderungen

Ein Softwareprojekt hat selten ein konkretes Ende. Wenn die Hauptanforderungen umgesetzt sind und die Benutzer damit arbeiten findet man immer noch mehr neue Anforderungen die man umgesetzt haben möchte oder Bugs die zu beheben sind. Außerdem kommt es vor, dass man Benutzer schulen muss oder manchmal wird eine Technologie obsolet die man durch eine neue ersetzen muss. Planen Sie die Themen Weiterentwicklung, Betrieb und Support mit ein. Man redet hier auch von dem Application Lifecycle Management (ALM)  welches 5 Phasen umfasst, 

 

**Konzeptphase**	 **- Realisierungsphase – Qualitätsphase – Rolloutphase – Wartungsphase** 

Das ALM unterscheidet sich je nach Vorgehensweise des Projektmanagements. Wir reden hier von zwei Vorgehen: Wasserfallmodell oder Agilität. Während das Wasserfallmodell die Software von Anfang bis Ende durchdenkt, arbeitet man sich in agilen Prozessen iterativ durch die einzelnen Phasen. 

Projekt Management

Startet man ein Software Projekt/Produkt muss man sich darüber im Klaren sein welches Projektmanagementvorgehen man wählt. In den letzten 10 Jahren hat sich die agile 

Vorgehensweise sehr stark durchgesetzt.

Wasserfallmodell

Konzept - Realisierung – Qualität – Rollout – Wartung

Agil



Man sollte kein Projekt mehr mit Wasserfallmodell entwickeln. Es hat sich einfach herauskristallisiert, dass in der Softwareentwicklung das Wasserfallmodell in vielen Fällen nicht zum Erfolg führt. 

Software Entwicklung ist ein sehr schwieriges Feld und es ist unmöglich vorherzusehen wie sich das Projekt entwickeln wird. Die Chaos Studie  veröffentlicht regelmäßig wie viel Prozent der Softwareprojekte erfolgreich sind, teilweise erfolgreich und wie viele abgebrochen wurden. Die teilweise erfolgreichen Projekte machen meistens die Hälfte aller Projekte aus. D.h. selbst bei einer gründlichen Planung verlaufen die meisten Projekte anders als man voraussagen kann. Deswegen ist es besser nicht zu viel Zeit in eine anfängliche Planungsphase zu verlieren, sondern mit wenigen Anforderungen zu starten und iterativ zu verbessern. Dies erfordert mehr Change als man vermuten mag. Ihre Projektleiter müssen in Schritten denken, die Kunden ständig mit einbeziehen und auch mal bereit zu sein das Projekt komplett auf den Kopf zu stellen. Es ist schwer die Kosten für ein agiles Projekt vorherzusehen. Am Ende ist es aber das Ziel das Geld das man investiert in das Richtige zu investieren. Das Management muss sehr viel Vertrauen in den Projektleiter haben und kann nicht erwarten, dass es einen genauen Plan der Entwicklung gibt. Die Vision des Produkts muss sauber definiert sein an dem sich der Projektleiter ausrichten kann. Steuerkreise und Meilensteine sind kontraproduktiv da sie die Entwicklung eher verlangsamen und dem Projektleiter die „Bewegungsfreiheit“ einschränken. Das heißt aber nicht, dass der Projektleiter einen Freibrief bekommt. Das Management darf sich jederzeit über den Fortschritt des Projektes informieren und auch ein Projekt stoppen, wenn es in die falsche Richtung läuft.

In der Software Entwicklung gibt es den Begriff des Pivotisierens. D.h. dass man eine Idee mitten drin vollkommen auf den Kopf stellt, weil man feststellt, dass die anfängliche Vision so nicht umgesetzt werden kann oder keinen Sinn macht. Das ist in der Entwicklung vollkommen normal, es sollte Sie eher verwundern, wenn ein Projekt nicht pivotisiert wurde.

Agiles Projekt Management

Agilität ist einer der Begriffe die in den letzten Jahren sehr häufig mit Erfolg in Unternehmen in der Zukunft in Beziehung steht. Die Begrifflichkeit ist schwer zu fassen. Darüber gibt es einen Haufen Bücher, Blogs, Diskussionen die man sich durchlesen kann. Man kann Agilität gut mit einem Ball - Teamsport vergleichen. Z.B. Fußball. Eine Mannschaft versucht zusammen ein Ziel zu erreichen im Normalfall der Gewinn des Spiels. 

Jeder Spieler agiert in seiner zugewiesenen Rolle selbstständig und versucht sein bestes damit das Team gewinnt. Der Trainer steht an der Seite, kann nur bedingt in das aktuelle Spiel eingreifen, das Management ist nur Zuschauer. Der Trainer hofft, dass er die Spieler richtig auf das Spiel vorbereitet hat. Nach dem Spiel wird das Spiel analysiert, ein Trainingsplan erstellt, eine Taktik entwickelt und versucht die Fehler die in dem Spiel passiert sind im nächsten Spiel zu vermeiden und sich kontinuierlich zu verbessern. Eine hierarchische Struktur wie sie in Unternehmen häufig zu finden sind könnte bei solchen sich schnell ändernden Prozessen wie bei einem Fußballspiel nicht funktionieren. Ein Stürmer kann ja nicht den Trainer fragen ob er den Ball wirklich ins Tor schießen soll, wie ein Mitarbeiter den Chef fragt ob er jetzt eine Bestellung freigeben darf.







Das Problem bei Fußball ist, dass die Situation sich von einem Moment auf den nächsten komplett ändern kann und das Team muss ohne Steuerkreis, Workshops und Besprechungen auf die Situation reagieren. Jedes Teammitglied muss ständig die aktuelle Situation im Blick behalten und entsprechend selbstständig darauf reagieren und auch mal die Rolle ändern, wenn es nötig ist. Z.B. ein Stürmer übernimmt die Verteidigung einer gefährlichen Szene, wenn es notwendig wird. 

Bei Fußball passieren auch ständig Fehler. Der Ball will nicht richtig gestoppt, ein Pass landet beim Gegner, die Positionierung eines Mitspielers ist falsch. Trotzdem hört man selten, dass sich die Teammitglieder gegenseitig Schuld zuweisen. Die Fehler werden akzeptiert und im Nachgang aufgearbeitet. Würde man hypothetisch eine Fußballmannschaft wie wir es aktuell kennen gegen eine hierarchisch geführte Fußballmannschaft spielen lassen, welches jeden nächsten Schritt erst mal mit dem Trainer abstimmen muss, wer würde hier gewinnen?

Dieses Verhalten könnte man als Agilität deuten. Stellen Sie sich Ihr Unternehmen vor welches sich von selbst auf neue Herausforderungen einstellt, in dem sich die Abteilungen neu positionieren, ohne dass die Hierarchie durchgreifen muss, ohne Eskalationsstufen, ohne endlose Workshops und Umorganisationen, ohne sich gegenseitig die Schuld zuzuweisen, ohne Projektleiter die ihr Projekt positiver darstellen als sie wirklich laufen und ohne Abteilungen die zu fest an Prozessen festzuhalten auch wenn Sie in manchen Fällen keinen Sinn ergeben und ohne Steuerkreise die nur alle Monate treffen und sich somit dringend benötigte Entscheidungen verzögern. Sondern Abteilungen die sich gegenseitig unterstützen, wenn Not am Mann und Fehlern positiv gegenüberstehen und sich ständig weiter verbessern zu wollen um die Vision Ihres Unternehmens umzusetzen.

Gerade jetzt wo disruptive Innovation von kleinen Firmen ganze Geschäftsbereiche bedrohen, muss man schnell reagieren können. Es gibt viele Beispiele bei denen Firmen nicht in der Lage waren auf eine disruptive Innovation zu reagieren obwohl es viele Jahre Zeit gedauert hat bis das Geschäftsmodell kaputt ging, Kodak oder Quelle werden immer wieder als Beispiele genannt. Sich diese Geschichten einmal näher anzusehen ist auf alle Fälle immer interessant um den Sinn von Agilität zu verstehen. Aber vielleicht können Sie erahnen welcher Change das für ein Unternehmen bedeuten kann?

Agilität bedeutet auch immer etwas Chaos. Man kann bei einem Teamsport auch nie vorhersagen was als nächstes passiert, es gibt Regeln und Taktiken die aber relativ viel Freiraum bieten. Bei Agilität gibt es weniger Prozesse an die man sich halten kann. Feste Prozesse geben Sicherheit, nehmen dem Mitarbeiter aber auch die Reaktionsfähigkeit, wenn neue Herausforderungen auf das Unternehmen einprasseln. Es wird mehr situativ entschieden, mehr versucht den gesunden Menschenverstand einzusetzen und das Ganze mit Know How der Mitarbeiter zu unterfüttern. Die Frage steht immer im Raum, halte ich mich an einen Prozess auch wenn es in dem speziellen Fall keinen Sinn ergibt? Als wichtigstes Instrument ist die Vision, das Ziel des Unternehmens. Das Management gibt die Vision, Mission und Strategie vor. Diese zu ändern muss für Abteilungen ausreichen damit diese sich neu ausrichten. 

Aber man versucht auch mit leichten Prozessen etwas Ordnung ins Chaos zu bringen. Dazu kann man auf das Vorgehensmodell von Scrum, Kanban, Extreme Programming in Teams und in abteilungsübergreifenden Projekten auf Less, Safe oder andere Modelle zugreifen. 

Die Stacey Matrix kann einem bei der Auswahl helfen:

Diese Matrix ist so zu lesen. Umso weiter sie weg vom 0 Punkt sich entfernen umso weniger Ahnung haben sie bei den Anforderungen (Y-Achse) oder bei der Technik (X-Achse). D.h. wenn Sie überhaupt keine Ahnung davon haben was Sie umsetzen möchten (Anforderungen) und wie es umzusetzen ist (Technik), landet Ihr Punkt im Chaos und sollten vielleicht einen Proof of Concept erstellen und mehr versuchen Ihre Anforderungen zu konkretisieren. Wenn Sie ganz nah am Null-Punkt sind, benötigen Sie keine Agilität. Wenn die Technik und die Anforderung vollkommen klar sind dann fangen Sie nicht mit agilen Prozessen an, dann arbeiten Sie im Wasserfallmodell. Das ist z.B. beim Support der Fall. Es kommt ein Supportfall herein, der wird abgearbeitet fertig.

Das Ziel das Sie verfolgen sollten ist, dass man über die Dauer eines Projektes immer näher an den Nullpunkt kommt. So kann es durchaus vorkommen, dass am Anfang eines Projektes erst Workshops und einen Proof of Concept (POC) anfangen, dann mit Scrum in eine konkrete Umsetzung starten und man dann auf einer bestimmten Stufe Kanban wechselt. Es wird wohl nicht so oft passieren, dass ein Software Entwicklungsprojekt von den Anforderungen und der Technik so klar ist, dass man mit Wasserfall arbeiten sollte, aber Kanban sollte Ihr Ziel sein. Wir werden später erklären warum.

Kurze Einführung in agile Prozesse

Scrum basiert auf Sprints. In zwei (kann variieren) Wochen Sprints werden neue Features entwickelt. Die Länge der Sprints sind fix und werden nicht geändert. Alle zwei Wochen dürfen sich die Features ändern. Man plant im Idealfall natürlich etwas weiter voraus und hat eine Vision des Produkts. Der Kunde wird, soweit bekannt, sehr stark in den Entwicklungsprozess eingebunden. Dafür gibt es eine dedizierte Rolle, den Product Owner. Der ist für den Kundenkontakt und für die Formulierung der Anforderung zuständig, die sogenannten User Stories. Diese werden priorisiert und an das Team weitergegeben, immer am Sprintanfang. Am Sprintende werden die Ergebnisse präsentiert und an den Kunden weitergegeben. Eine wichtige Rolle kommt dem Scrum Master zu. Dieser ist prinzipiell dazu da, dass der Scrum Prozess eingehalten wird, dass Probleme und Fehler erkannt werden und dass das Team sich weiter verbessert.

Kanban besteht im Prinzip wie in der Produktion aus einem Board mit den Arbeitsschritten und die Anzahl wie viele Aufgaben maximal in dem Arbeitsschritt gleichzeitig ausgeführt werden dürfen. Das führt von einem Push zu einem Pull Prinzip und dazu, dass man herausfindet wo die Engpässe sind. 

Auch wenn es keine dedizierten Rollendefinitionen gibt sollte man zumindest einen Mitarbeiter die Aufgabe geben die Kundenanforderungen aufzunehmen und einen agilen Coach beschäftigen. Der Vorteil von Kanban ist, dass die Arbeitsergebnisse direkt nach Abschluss sofort zur Verfügung gestellt werden und man nicht auf ein Sprintende wartet.

Agilität und Agile Prozesse unterscheiden sich sehr stark von den aktuell bekannten und gewohnten Vorgehensweisen. Ein Chef der das Team führt, der Ziele definiert, Entscheidungen trifft, neue Mitarbeiter einstellt und der Herr über die Gehälter ist, gibt es hier nicht. Man teilt die Aufgaben des Chefs Mitarbeiterführung, fachlich Verantwortlicher und technischer Entscheidungsträger auf. Mitarbeiterführung übernimmt der agile Coach, fachlich Verantwortlich wird der Product Owner und technische Entscheidungen trifft das Umsetzungsteam. Wenn Sie zu dem Chef noch einen Product Owner und agile Coach beschäftigen führt zu einem Machtüberhang, wenn der Chef und der agile Coach gleichzeitig versuchen die Mitarbeiter zu führen und ihnen Feedback geben. Es kommt manchmal auch zu einem Machtvakuum, wenn der Chef sich komplett rauszieht der agile Coach aber gar nicht den Einfluss auf die Mitarbeiter haben kann den er bräuchte, weil der Chef das Gehalt erhöhen kann. Deswegen muss man hier eine gute Regelung finden, z.B. könnte der Chef der agile Coach werden oder ein Chef übernimmt mehrere Teams. Auf dieses Problem sollten sie großes Augenmerk legen.

Es gibt noch einen anderen Grund Agilität einzuführen. Gute Software Entwickler sind oft Menschen die aus intrinsischer Motiviation Software programmieren (Ich persönlich habe mit 12 Jahren das erste Mal versucht freiwillig Programme zu schreiben). Geld steht oft nicht so im Vordergrund eher der Reiz an der Technologie und die Herausforderung Probleme zu lösen. Es sind aber auch oft kreativ denkende Menschen die einen gewissen Freiraum benötigen. Agile Prozesse nehmen sehr gut auf die Bedürfnisse von Software Entwicklern Rücksicht. Man sollte sich auch damit auseinandersetzen, dass gute Software Entwickler nicht immer von Haus aus gute Softskills mitbringen und dass es einen fähigen agilen Coach benötigt der mit diesen Leuten umgehen kann.

Der Umstieg der Software Entwicklung auf agile Vorgehensmodelle kann in bisher hierarchisch geführten Unternehmen ziemlich daneben gehen. Man sollte schon laufende Projekte nicht unbedingt auf Scrum oder Kanban umstellen. Das kann zu einer größeren Verzögerung des Projektes führen. Allerdings ist davon auszugehen, dass Unternehmen die nicht auf Agilität zumindest in der Software Entwicklung setzen, in Zukunft einen sehr großen Wettbewerbsnachteil erleiden. Wieder ein Grund mehr klein anzufangen und nicht gleich das ganze Unternehmen auf Agile umzustellen. Fangen Sie mit einem Team an und begleiten Sie das Team sehr intensiv wie gut der Umstieg funktioniert. Räumen Sie Hemmnisse beiseite, dann können weitere Teams umstellen. Suchen Sie sich Leute die Lust auf eine Veränderung haben und achten Sie darauf, dass es keine Störenfriede gibt. 

Wenn Ihre Mitarbeiter seit Jahren oder Jahrzehnten gewohnt sind das umzusetzen was ihnen der Chef sagt wird der Umstieg auf Agile womöglich sehr schwerfallen.

Lean software development

Bevor wir langsam in die Technik einsteigen noch ein paar Worte zu Lean. Lean kommt aus der Produktion und besteht aus mehreren Prinzipien die auch Überschneidungen mit der Agilität haben. Diese Prinzipien werden uns immer wieder begegnen, hier die wichtigen für die Software Entwicklung:

Verschwendung vermeiden

Man sollte in seinem Projekt nur die Features umsetzen die man auch wirklich braucht. Keine unnötigen Features, keine zu weit vorrauschauenden Planungen was vielleicht kommen könnte. Kleine Schritte um zu sehen wie die Kunden reagieren. Keiner kann in die Zukunft schauen und Software Entwicklung ist oft die Suche im Nebel den richtigen Weg durchs Moor zu finden.

Lernen unterstützen

Mitarbeiter sollten einiges an Zeit investieren können um auf den neuesten Stand zu bleiben. Eine Auslastung von maximal 80% für das Projekt ist anzustreben. Die restliche Zeit können Entwickler sich mit neuen Themen beschäftigen. Stellen Sie sich eine 100% Auslastung der Autobahn vor, das bedeutet normalerweise Stau oder stockender Verkehr. Außerdem verlieren die Mitarbeiter relativ leicht den Anschluss an technologische Entwicklungen. Vermeiden Sie es unbedingt Mitarbeiter in Prozenten auf verschieden Themen aufzuteilen. Verschiedene Projekte mit unterschiedlichen Anforderungen im Blick zu behalten ist sehr schwer. Dazu noch der Druck durch mehrere Projektleiter ihre Arbeit zu bevorzugen ist für kreative Arbeit nicht förderlich.

So spät entscheiden wie möglich

Wie man ein Feature umsetzt sollte natürlich dann entschieden werden, wenn das Feature umgesetzt wird. Auch die Technologie die eingesetzt wird sollte nicht schon im vornherein feststehen da man damit Bedingungen setzt die es später unnötig erschweren Features umzusetzen.

So früh ausliefern wie möglich

Ein sehr zentrales Element in der Software Entwicklung. Hier fällt oft das Wort MVP, das Minimum Viable Product. Eine Idee die Sie haben ist oft auch erst mal eine These die es zu überprüfen gilt. Oft weiß man gar nicht ob die Idee von Nutzern angenommen wird und muss erst einmal überprüfen wie gut die Idee beim Kunden ankommt. Um nicht zu viel Geld in eine Idee zu investieren die der Kunde nicht nutzt, muss man so schnell wie möglich herauszufinden ob die Idee gut oder schlecht ist um im Notfall schnell die Reißleine zu ziehen. Deswegen ist es in einem Projekt sehr wichtig sich zu überlegen welche Features sind in einer ersten Version unabdinglich und was kann man nach hinten schieben.

Der Vorteil in der Software Entwicklung ist, dass man per Update neue Features nachliefern kann. Das kann man bei anderen Dingen nicht wie z.B. Hardware. Ich kann dem Kunden keinen Laptop zuschicken der erst mal nur eine kleine Festplatte hat und diese dann bei Bedarf auf Knopfdruck erhöhen.

Wenn Sie ein Auto kaufen und Sie hätten die Wahl das Auto innerhalb eines Monats zu bekommen welches fährt, aber der Radio und die Klimaanlage würde in den nächsten zwei Monaten per Knopfdruck über Nacht nachgeliefert oder Sie müssen für das komplette Auto drei Monate warten, was von den beiden Kaufmodellen würden Sie wählen?

Bei der Software ist das eine Möglichkeit schnell einen Mehrwert für den Kunden zu generieren und dann nach und nach die neuen Anforderungen nachzuliefern. Deswegen wird Software immer Iterativ entwickelt. Wichtige Anforderungen zuerst entwickeln, ausliefern, Feedback einholen, nächste Anforderungen entwickeln, ausliefern, Feedback einholen. Das bewahrt die Teams vor einer langen Entwicklungszeit ohne Mehrwert und kann dabei helfen das Projekt, wenn es falsch verläuft auch frühzeitig zu stoppen und Kosten zu reduzieren. Um einen MVP zu definieren helfen Moderationswerkzeuge wie z.B. Userstory Mapping 

Verantwortung an das [Team](https://slack.com/intl/de-de) geben

Das Team besteht aus den Experten die am besten entscheiden können wie ein Thema umgesetzt wird. Software Entwicklung ist ein sehr komplexer Prozess bei dem viele Themen eine Rolle spielen und ständig neue Technologien auf dem Markt erscheinen. Hier einen Überblick zu behalten ist schon schwer genug, aber jede Technologie zu verstehen ist nicht möglich. Deswegen muss derjenige der das Wissen hat entscheiden dürfen wie etwas umgesetzt wird. Damit das Team aber die Verantwortung übernehmen will muss es im Unternehmen erlaubt sein, Fehler zu machen ohne Repressalien zu fürchten. Außerdem muss dem Techniker Zeit gegeben werden sich mit den neuen Technologien auseinanderzusetzen. Und seien wir ehrlich, ein Steuerkreis bekommt am Ende drei Vorschläge und eine Empfehlung und entscheidet, wenn er intelligent ist nach der Empfehlung. Dann kann man sich diesen auch sparen.

Kundenorientierung

Der Kunde muss von Anfang an mit einbezogen werden. Wenn man einen konkreten Kunden hat der die Entwicklung bezahlt ist das einfach. Wenn man diesen nicht hat, kann man mit Personas arbeiten bzw. auch Umfragen starten. Umso wichtiger ist es aber auch sich schnell Feedback vom Markt zu holen in dem man schnell einen MVP ausrollt.

Team

Nachdem Software Entwicklung ein komplexer Vorgang ist baut man normalerweise Teams auf mit verschiedenen Spezialisten auf einem Gebiet um eine Software in allen Facetten umsetzen zu können. Bei größeren Anwendungen baut man mehrere Teams auf. Je nach Typ der Anwendung benötigt man in den Teams unterschiedliche Spezialisten. 

- Product Owner
1. Legt die Vision und die Anforderungen fest und verantwortet somit auch wie gut das Produkt beim Kunden ankommt.
1. 
- Software Architekt
1. Legt die Softwarearchitektur fest, ist erster Ansprechpartner für den PO für technische Fragen und entwickelt trotzdem Features.
1. 
- Entwickler 
1. Die Entwickler schreiben den Code. Welche Technologien diese können müssen hängt von dem Projekt ab.
1. 
- Tester
1. Tester müssen sich gut mit Testing auskennen. Sie müssen Testpläne schreiben können und sich auch mit der Testautomatisierung auskennen.
1. 
- Deployer (Devops)
1. Der Deployer kümmert sich um das Ausrollen und Monitoring der Software. Er ist für alle Schritte bis dahin verantwortlich und dafür, dass die meisten Aufgaben automatisiert ablaufen.

DevOps

DevOps ist ein Wort das in letzter Zeit vor allem für Rolle eines Mitarbeiters verwendet wird, der den Rollout der Software und den Betrieb übernimmt. DevOps ist aber eher eine Idee, ein Mindset das sehr stark den Lean Gedanken in die Software Entwicklung bringt. Früher war es so, es gab Teams die haben entwickelt und es gab Teams die mussten die Software ausrollen und supporten. Diese waren getrennt was immer wieder zu Problemen geführt hat. Die Entwickler haben sich nicht wirklich dafür verantwortlich gefühlt, dass die Software richtig läuft und die Supporter haben die Schuld, wenn etwas nicht lief den Entwickler gegeben. Dazu kam dass man Übergaben benötigt hat und Dokumentation, damit Supporter wussten wie sie die Software ausrollen mussten. Deswegen hat man irgendwann angefangen die Entwickler (Developer also Dev) und die Supporter (Operations also Ops) zusammen in ein Team gesteckt und gesagt: Ihr seid für das komplette Produkt verantwortlich. Also DevOps, ein Team das vom Requirement Engineering bis zum Betrieb und Wartung alles macht.

Fehler passieren

Sie sollten sich in Ihrem Unternehmen überlegen wie sie mit Fehlern umgehen. Fehler passieren in der Software Entwicklung, da kann man nichts dagegen tun. Die Software Entwicklungscommunity hat schon viele Ideen wie man die Qualität der Entwicklung erhöht. Diese Methoden wie Testautomatisierung sollten unbedingt eingesetzt werden. Nichts destotrotz sollten Sie den Teams die Angst nehmen Fehler zu machen. Es gibt Firmen die feiern z.B. eine Worst–Failure-Party wo Teams ihre schlimmsten Fehler präsentieren und die Lösung, dass diese nicht wieder auftreten. Das wichtige daran ist es, dass Fehler offen ausgesprochen werden, damit man eine Lösung finden kann und Strategien, dass solche Fehler nicht mehr passieren. Es gibt nichts Schlimmeres, als dass Fehler verschwiegen werden. Umso schneller Fehler kommuniziert und behoben werden umso weniger Kosten entstehen. Eine Strategie wie diese Fehler in Zukunft vermieden werden sollte ausgearbeitet werden. Was nicht passieren sollte ist, dass ein und derselbe Fehler immer wieder auftritt.

Agilität bedeutet nicht, dass der Druck auf die Projekte und die Teams nicht hoch sein kann. Auch hier kann man Fußball als Beispiel bemühen. Wenn man in der Bundesliga spielen möchte braucht man sehr gute Fussballspieler, die selten sind und die hoch bezahlt werden. Wenn ein Spieler von Spiel zu Spiel keine Leistung zeigt wird er ausgemustert. D.h. man darf Agilität nicht mit Kuschelkurs verwechseln. Der Druck kann hier viel höher auf den Mitarbeitern lasten da sie selber Entscheidungen treffen müssen. Das liegt nicht jedem. Man braucht für eine erfolgreiche Agilität gute Mitarbeiter die motiviert sind, flexibel auf Herausforderungen reagieren, die Verantwortung übernehmen und die wissen was sie tun. Diesen Mitarbeitern passieren auch genügend oft Fehler, aber auf einem anderen Niveau mit einer anderen Lernkurve. 

Heutzutage haben die Arbeitgeber das Problem, dass gute IT-Fachkräfte schwer zu finden bzw. diese sehr begehrt sind und oft ist ein Gehalt nicht das ausschlaggebende Argument ist für einen Arbeitgeberwechsel. Hier müssen Sie sich überlegen wie Sie gute Mitarbeiter an ihr Unternehmen binden. Eine gute Idee kann schon einmal sein, wenn Sie für IT-Fachkräfte Ihre Einstellungsprozesse anpassen um auch mal schnell einen guten „Fang“ machen zu können.

Requirements Engineering

Es ist eine Sache eine Idee für die Digitalisierung zu haben und eine andere die Branche zu verstehen und eine Anwendung zu schreiben die von den Nutzern akzeptiert wird und sich gegen Konkurrenz durchsetzen kann.

Das Requirements Engineering ist unheimlich wichtig, deswegen gibt es dafür im Idealfall eine eigene Rolle die sich dieser Aufgabe widmet. Der Product Owner kümmert sich darum, dass die richtigen Anforderungen in das Produkt kommen und trägt somit auch die Verantwortung für den Erfolg des Produkts. Der Begriff des Product Owners kommt aus dem Prozess von Scrum kann aber auch in anderen Vorgehensmodellen eingesetzt werden. Requirements bzw. Features oder auch Anforderungen werden auf fachlicher Basis aus Sicht des Nutzers erfasst, sogenannte User Stories. Eine User Story besteht aus: 

**Welcher Nutzer möchte was und warum.** 

Das sind drei wichtige Fragen um zu klären, dass die Anforderung auch wirklich wichtig ist und seinen Grund hat. Wenn man das Wer oder das Warum nicht beantworten kann ist die Anforderung vielleicht gar nicht so wichtig. 

Ein wesentlicher Bestandteil sind die **Akzeptanzkriterien**, also die Fragen wann gilt die Anforderung als umgesetzt. Eine Liste von Kriterien die erfüllt sein müssen. Das hilft unheimlich im Verständnis der Anforderung. Die Entwickler sollten so genau wie möglich wissen was die User Story beinhaltet und wenig Interpretationsspielraum haben. Interpretationen führen zu Verschwendung von Entwicklungsressourcen. Die User Stories werden in ein Product Backlog abgelegt einer priorisierten Liste von User Stories und vom Team von oben nach unten abgearbeitet. Nur die obersten User Stories müssen im Detail vorliegen. Es kann auch viele User Stories geben die erst mal nur eine Überschrift beinhaltet um eine Idee oder eine Anforderung an spätere Versionen zu dokumentieren. In der Formulierung von User Stories ist ein Konjunktiv unbedingt zu vermeiden, damit hier keine Missverständnisse auftreten.

User Stories werden in manchen Teams geschätzt. Diese Schätzung basiert nicht mehr auf echten Zeiteinheiten sondern auf einer fiktiven Einheit, sogenannte Story Points die der Fibonacci Reihe entsprechen. Also 1, 2, 3, 5, 8, 13, 21. Man schätzt die Zeit auf Basis der User Stories nicht mehr absolut in Zeit, sondern relativ im Verhältnis zwischen den Anforderungen. Der Mensch ist scheinbar besser darin relative Schätzungen abzugeben. Wie groß ist eine Ameise und wie groß ist ein Elefant ist schwieriger als die Frage was ist größer eine Ameise oder ein Elefant. Die Summe der Story Points die das Team in einem Sprint schafft pendelt sich nach einer gewissen Zeit auf einen stabilen Wert ein so dass man nach ein paar Sprints relativ genaue Voraussagen machen kann wann welche Anforderung umgesetzt ist und wie lange ein Projekt dauert. Schätzungen auf konkrete Zeit hat sich in den letzten Jahrzehnten immer wieder als sehr fehlerhaft erwiesen.

Die Priorisierung des Produkt Backlog kann sich als schwieriges Optimierungsproblem herausstellen. Welches der Userstories als nächstes gemacht werden hängt dabei von vielen Faktoren ab:

- Nutzen für den Kunden
- Aufwand
- Kundenwunsch
- Abhängig vom Teamaufbau
- Abhängigkeiten zu anderen Teams
1. 

Eine User Story die schnell umgesetzt ist und viel Nutzen für den Kunden bringt ist natürlich eher zu Priorisieren als eine US die lange dauert und wenig Nutzen bringt. Aber es kann auch sein, dass man zwei Userstories nicht in einem Sprint erledigen kann, weil sonst zu viele Entwickler auf den gleichen Dateien arbeiten sie sich gegenseitig blockieren. Eine falsche Priorisierung der User Stories kann zur Verzögerung des Projektes führen.

Funktionale und nicht funktionale Anforderungen

Man unterscheidet bei Anforderungen zwischen funktionale und nicht funktionale Anforderungen. Um das zu verdeutlichen versuchen wir das mit einem Haus zu vergleichen. Ein Hausbauer hat an sein Haus die funktionale Anforderung, er möchte darin wohnen, kochen, duschen, schlafen, manch einer möchte Basteln oder einen großen Raum für eine Eisenbahn oder jeden Tag im Pool schwimmen. Das sind konkrete Dinge die ich in meinem Haus tun möchte. Dazu benötigt man eine Küche, ein Sofa, ein Bett, vielleicht einen Pool. Die nicht funktionalen Anforderungen sagen etwas über den Komfort aus. Ich kann in einem kleinen kalten Pool schwimmen oder in einem beheizten mit Gegenstromanlage.

So verhält es sich auch bei der Software: Die Anforderung: „Ich möchte eine Tabelle mit den Aufträgen eines Kunden angezeigt bekommen“ ist leicht umzusetzen. Aber wer sagt denn wie lange sie auf das Ergebnis warten möchten. Wenn Sie in einem globalen Unternehmen arbeiten mit Hundertausenden von Aufträgen ist das gar nicht so leicht die Aufträge in einer schnellen Zeit anzuzeigen. Das wird über die nicht funktionelle Anforderung Performance angegeben. Funktionale Anforderungen zu definieren ist recht einfach aber nicht funktionale Anforderungen bestimmen wieviel Geld sie für das Projekt ausgeben. Wie beim Pool, ein kleiner kalter Pool kostet weniger als ein großer beheizter.

Nicht funktionale Anforderungen teilen sich in:

- Z[uverlässigkeit](https://de.wikipedia.org/wiki/Zuverl%C3%A4ssigkeit_(Technik)) (Systemreife, Wiederherstellbarkeit, Fehlertoleranz)

Hier hört man oft die unbedarfte Aussage, das System muss immer verfügbar sein. Das ist nicht unmöglich aber wird Ihre Kosten in unsagbare Höhen treiben. 99,5% ist so die Grenze ab dem es richtig teuer wird.

- Aussehen und Handhabung ([Look and Feel](https://de.wikipedia.org/wiki/Look_and_Feel))

Das Aussehen kann von schlicht bzw. Kommandozeile bis hin zu einem super Design. Alles eine Frage des Geldes. Software Entwickler sind nicht für gutes Design bekannt. Benötigen Sie ein schickes Design sollten Sie sich einen Designer suchen.

- [Benutzbarkeit](https://de.wikipedia.org/wiki/Gebrauchstauglichkeit_(Produkt)) (Verständlichkeit, Erlernbarkeit, Bedienbarkeit)

Glauben Sie nicht, dass die Benutzbarkeit eines Programms selbstverständlich ist. Dafür gibt es den Beruf des UX – Designers. Und der muss die Verwender sehr intensiv befragen, Tests machen um herauszufinden ob das Programm auch verständlich ist.

- [Leistung](https://de.wikipedia.org/wiki/Leistung_(Informatik)) und [Effizienz](https://de.wikipedia.org/wiki/Effizienz_(Informatik)) (Antwortzeiten, Ressourcenbedarf, Wirtschaftlichkeit)

Wie schnell muss Ihre Anwendung reagieren. Auf welchen Systemen wird sie laufen. Welche Auswertungen benötigt man schnell auf welche kann man länger warten. Gerade bei großen Datenmengen ist hier normalerweise eine Aussage nötig. Das filtern einer sehr großen Datenmenge dauert und der Entwickler muss sich überlegen wie er das gut hinbekommt.

- Sicherheitsanforderungen (Vertraulichkeit, [Informationssicherheit](https://de.wikipedia.org/wiki/Informationssicherheit), Datenintegrität, [Verfügbarkeit](https://de.wikipedia.org/wiki/Verf%C3%BCgbarkeit))

Wer darf welche Daten sehen, welche Rollen und Rechte wird es geben müssen. Das ist ein riesiges Thema welches genau betrachtet werden muss. Unterschätzen Sie die Sicherheit nicht. Wenn Ihr Unternehmen in der Zeitung steht, dass tausende private Nutzerdaten geklaut wurde kann Sie das Ihre Existenz kosten.

- [Korrektheit](https://de.wikipedia.org/wiki/Korrektheit_(Informatik)) (Ergebnisse fehlerfrei)

Die Frage wie schlimm es ist, wenn manche Daten nicht ganz korrekt gespeichert werden. Bei globalen Webanwendungen muss man manchmal auf Grund der Performance auf Korrektheit verzichten. Also ich sehe meine Daten schnell dafür kann es vorkommen, dass ich nicht auf dem aktuellsten Stand bin.

- [Portierbarkeit](https://de.wikipedia.org/wiki/Plattformunabh%C3%A4ngigkeit) und [Übertragbarkeit](https://de.wikipedia.org/wiki/%C3%9Cbertragbarkeit) (Anpassbarkeit, Installierbarkeit, Konformität, Austauschbarkeit)

Auf welcher Hardware bzw. Betriebssystem muss das System laufen. Die meisten Apps werden heutzutage so entwickelt, dass sie auf vielen unterschiedlichen Geräten laufen. Smartphones, Tablets, Mac, Windows Rechnern vielleicht sogar Windows. Deswegen eignen sich hier Webtechnologien sehr gut.

- [Skalierbarkeit](https://de.wikipedia.org/wiki/Skalierbarkeit) (Änderungen des Problemumfangs bewältigen)

Skalierbarkeit ist durch das Internet ein wichtiges Thema geworden. Webanwendungen können plötzlich „durch die Decke gehen“. Wenn Sie darauf nicht vorbereitet sind und Ihr Webshop einen massiven Ansturm nicht verkraftet, gehen Ihnen Aufträge und Kunden verloren.

- [Wartbarkeit](https://de.wikipedia.org/wiki/Wartbarkeit), Änderbarkeit (Analysierbarkeit, Stabilität, Prüfbarkeit, Erweiterbarkeit)

Wie oft wird sich Ihre Software ändern müssen. Bei Software die von Gesetzen abhängen wie Steuersoftware werden Sie häufige Änderungen vornehmen müssen. 

- Betrieb und Umgebungsbedingungen

Wo wird Ihre Software laufen, in der Cloud oder direkt auf dem PC. Sind diese PCs gut ausgestattet, kann man von guten modernen Rechnern ausgehen oder sind es etwas ältere PCs

Rahmenbedingungen

Zu jedem Projekt gibt es Rahmenbedingungen die in die Entwicklung einfließen z.B. wie das Budget, Termine, die Qualität, Anzahl der Mitarbeiter oder Prozesse bei sicherheitskritischer Software die sich auf das Produkt auswirken. Hier gibt es oft einen Konflikt zwischen dem Management und den umsetzenden Teams. Das Management möchte mit wenig Geld ein großes Projekt in kurzer Zeit stemmen, die Entwickler möchte sich die Zeit nehmen hohe Qualität auszuliefern. Hier hat der Product Owner die Aufgabe aus den Requirements und den Rahmenbedingungen den maximalen Mehrwert für den Kunden herauszuholen.

Fazit: 

Schließen wir hier mit Projekt Management Themen ab und gehen in die Technik. Über das Thema gibt es eine Menge Bücher. Beschäftigen Sie sich damit, am Ende dieses Buches ist Ihnen hoffentlich bewusst, dass Agilität mit modernen Software Architekturen und Technologien Hand in Hand gehen und dass sie einen Wettbewerbsnachteil erleiden werden, wenn Agilität und Lean Prinzipien nicht verwendet werden. Aber der Umstieg auf Agilität hat sehr viele Fallstricke und kann gehörig nach hinten losgehen. Starten Sie klein und übernehmen Sie sich nicht, akzeptieren Sie Fehler, lernen Sie aus Ihnen, lassen Sie Transparenz zu und bringen Sie Geduld mit.

Steigen wir in das technische Wissen ein. Es sind zwei größere Kapitel. Einmal die technischen Grundbegriffe. Hier erläutern wir Themen wie den Hardwareaufbau, wie Hardware mit Software zusammenhängt, wie Software erstellt wird, wie das Internet funktioniert und so weiter. Im nächsten Kapitel „Umsetzung einer Idee“ bauen wir auf dem gelernten auf und versuchen uns an einer theoretischen Umsetzung einer Applikation.

 _q_

_Umsetzung einer Idee_

Wir haben jetzt wichtige Kapitel der Software Entwicklung behandelt. Wie nutzt man dies jetzt um eine Idee umzusetzen. Lassen Sie uns das einmal zwei Punkte theoretisch durchspielen, das Requirements Engineering und die Software Architektur. Eine detailiertere Beschreibung der Software Entwicklung würde den Rahmen dieses Buches sprengen. 

Die Idee nehmen wir einfach eine App mit der man mit zufälligen anderen Menschen chatten kann. Das gibt es schon, ist nichts Außergewöhnliches, aber das ist hier vollkommen irrelevant.

Idee konkretisieren

Unsere Vision könnte sein: „Wir wollen die Verständigung zwischen Menschen verbessern, indem wir zufällig ausgewählte Menschen anonym miteinander chatten lassen“. Macht jetzt vielleicht nicht viel her, ist aber auch nicht der Fokus in diesem Buch. Nächster Schritt wären die Funktionen. Sie können sich selber einmal grobe Punkte überlegen die sie umsetzen würden. 

Hier ein paar Ideen:

- Login über Facebook und andere bekannte Provider.
- Wenn man die App öffnet kommt man direkt auf ein Menü wo man 3 Dinge auswählen kann:
-- Chatten
-- Verlauf
-- Themen
-- Profil
- Wenn man auf Chatten klickt startet eine Suche die einen mit einem anderen Chatpartner der noch frei ist und der auch auf Chatten geklickt hat verbindet
- Wenn die Suche erfolgreich ist kann ist oben der Chatverlauf und unten die Textbox
- Man kann Nachtrichten schicken und den Chatkontakt als positiv oder negativ markieren. 
- Wird der Chat negativ markiert dann wird der Chatkontakt geblockt.
- Wenn beide den Chatkontakt mit positiv markieren sind die beiden Chatkontakte verbunden und sie können weiterchatten bis einer auf negativ drückt.
1. 
- Wenn man auf Verlauf klickt werden einem die letzten Chats angezeigt. Man kann mit Chatkontakten die von beiden als positiv markiert sind weiterchatten.
- Unter Themen kann man stichpunktartig Themen aufschreiben für die man sich interessiert.
- Unter Profil kann man seine Sprachen festlegen in denen man chatten möchte.

Gehen wir damit einmal ins Rennen. Nächster Schritt wäre jetzt den MVP zu klären und welche Anforderungen man zum Starten der App wirklich benötigt. Gehen wir davon aus das wir nur den Punkt Chatten benötigen. Man klickt darauf und wird mit einer zufälligen anderen Person die auch gerade auf Chatten geklickt hat und kann mit diesem Textnachrichten austauschen.

Diese kann man jetzt noch in Userstories aufteilen:

- Der Nutzer öffnet die App und es erscheint die Startseite mit den Button Chatten damit er die App überhautp nutzen kann
- Der Nutzer klickt auf Chatten um sich für zufälliges Chatten anzumelden. Es wird ein Ladebalken angezeigt der visualisiert, dass gerade verfügbare Chats gesucht werden. Die Chats werden priorisiert nach gleichen Ländern gesucht.
- Wenn ein Chat gefunden wurde, wird unten ein Texteingabefeld angezeigt wo der Nutzer Text eingeben kann um auch Nachrichten verschicken zu können
- ….

Nicht funktionale Anforderungen sollte man natürlich nicht vergessen:

- Die App sollte auf so vielen mobilen Geräten wie möglich funktionieren. Dazu gehörten Smartphones und Tablets
- Die App sollte von sehr vielen Nutzern gleichzeitig verwendet werden können.
- Chats sollten priorisiert nach Sprachen automatisch gesucht werden.

Wir wollen das jetzt nicht weiter vertiefen. Die grundsätzliche Idee dahinter sollte klar sein.

Software Architektur

Im nächsten Schritt sollte man sich Gedanken machen wie man dieses Projekt technisch umsetzt. Hier kommt die Software Architektur ins Spiel die sich mit den Fragen beschäftigt. Die App soll übergreifend auf den gängigen Smartphones laufen als Android und IPhone Handys und Tablets. Versuchen wir mal die Gedanken eines Software Architekten einzufangen:

- Die App zielt darauf ab, auf vielen Endgeräten weltweit gleichzeitig performant zu funktionieren. Dazu kommt, dass im Idealfall in kurzer Zeit die Anzahl der Nutzer sehr stark ansteigt. Deswegen muss die Software sehr gut skalieren. 

- Da die App von einer Kommunikation zwischen Usern lebt, ist es sinnvoll die Anwendung in zwei verschiedene Ebenen aufzuteilen. Die App auf der einen Seite, also das Programm welches beim Kunden auf dem Endgerät läuft und einen (oder mehrere Services) welches die Nutzer dann am Schluss zufällig zusammenbringt. Das nennt man die Aufteilung in Frontend und Backend. Das Frontend läuft auf dem Endgerät und kommuniziert mit dem Backend welche auf zentralen im Internet verfügbaren Servern läuft.
1. 

1. 
- Nachdem wir eine große Anzahl von Nutzern gleichzeitig verarbeiten können müssen, wäre es wichtig, dass wir das Backend auf mehreren Servern laufen lassen können, da ein Server immer begrenzte Ressourcen hat. Das führt aber dazu, dass wenn zwei Nutzer die sich auf unterschiedlichen Backends verbinden erst mal nicht sehen würden.
1. 

- Deswegen kann entweder eine Kommunikation zwischen Backends aufbauen, eine gemeinsame Datenbank verwenden oder die gesamte Funktionalität des Backends in kleine unabhängige Services aufteilen. Z.B. Profil Anfragen verarbeitet ein Service auf einem Server und das Finden von geeigneten Random Chats ein anderer. Das würde man dann Microservice Architektur nennen. Macht vor allem dann Sinn wenn man mit mehreren Teams arbeitet. 

        

- Das Backend kann man mit vielen verschiedenen Programmiersprachen entwickeln. Das kommt etwas auf den Anwendungsfall an. Diese Entscheidung hängt daran welche Programmiersprachen die Entwickler beherrschen. Hier kann man Nodejs, GO, Java oder andere Sprachen nutzen.
1. 
- Eine Datenbank wird benötigt da wir, falls ein Backend neu gestartet werden muss, den Zustand nicht verliert z.B. die aktuell angemeldeten Benutzer. Außerdem kann damit jedes Backend auf die aktuelle Liste aller Benutzer zugreifen. Hier muss aber auch wieder eine Datenbank gewählt werden die skalierbar ist, sonst hat man seine Skalierung verloren. Dafür eignen sich gut dokumentbasierte Datenbanken, z.B. MongoDB
1. 

1. 
- Der Backend-Service muss global im Internet einfach erreichbar sein und muss auch mit großen Anfragen gut zurechtkommen. Deswegen sollte der Service in einer Cloud installiert werden. In Frage kommen dafür Heroku, AWS, Azure, Google oder andere. Die Entscheidung hängt wieder von vielen Faktoren wie der Erfahrung der Entwickler im Team, aber auch die anfallenden Kosten. Dann muss man sich entscheiden welche der Angebote innerhalb der Cloud für einen passen. Benötigt man einen Kubernetes Cluster oder reicht eine normale Webapp. Auch die Datenbank muss in der Cloud als Service verfügbar sein. In Azure z.B. könnte man statt MongoDB die CosmosDB nehmen.

1. 

- Ein Großteil des Traffics dürfte durch den Austausch von Nachrichten entstehen. In der aktuellen Überlegung müsste eine Nachricht von dem Endgerät an das Backend geschickt werden. Das Backend muss die Nachricht in die Datenbank schreiben, da wir nicht sicher sein können, dass die Apps mit den gleichen Backends verbunden sind. Somit würde man viel Last auf der Datenbank erzeugen. Das könnte man abfedern in dem man die Funktionalität die Nachrichten zu versenden und empfangen nicht über das Backend laufen lässt, sondern dafür einen eigenen Service nutzt, der nur für Daten verschicken und empfangen genutzt werden kann. Dieser Service sollte sehr ausfallsicher sein. Hier kann man z.B. Nats.io, RabbitMQ oder Kafka nutzen, sogenannte Message Broker. Das sind Services die extra dafür entwickelt wurden eine große Anzahl von Nachrichten skalierbar zu versenden. Damit könnte man das Backend für die Registrierung von Nutzern nutzen sowie das zufällige zusammenschließen von Nutzern. Die Chats an sich laufen dann aber über den Message Broker.Damit könnte es sein, dass wir das Backend nicht skalieren müssen. Aber natürlich sollte das trotzdem in Zukunft möglich sein, somit sollte man eine skalierbare Datenbank wählen.
1. 
1. 
- 
1. 
- Im Frontend muss man mehrere Endgeräte unterstützen. IOS und Android sind zwei unterschiedliche Betriebssysteme und nicht kompatibel so dass man das Frontend zweimal programmieren muss mit unterschiedlichen Technologien, Swift für IOS und Java für Android. D.h. die Entwickler müssen auch beide Technologien kennen. Um das zu vermeiden kann man auf Technologien setzen wo man eine Codebasis programmiert diese aber auf beiden Geräten laufen, die haben aber öfters Einschränkungen und können nicht alle Funktionen eines Handys voll ausnutzen. Z.B. könnte man rein browserbasiert arbeiten mit HTML, CSS, Javascript. Das hätte den Vorteil dass man die Applikation ohne Installation auf allen Endgeräten nutzen kann. Der Nachteil ist, dass man Handyfunktionen wie Sensoren oder GPS nicht so einfach nutzen kann. Geeignet wären Technologien wie Flutter, Cordova oder React Native für das Frontend.

Diese Entscheidung die der Software Architekt zusammen mit dem Team fällt, hängt an den Anforderungen, den Möglichkeiten der Technologien und der Erfahrung der Entwickler ab. Wenn ein Team schon viel Erfahrung mit Webtechnologien hat, warum soll man diese Erfahrung nicht einsetzen, auch wenn man vielleicht ein paar Nachteile in Kauf nehmen muss, wie der Zugriff auf rudimentäre Handyfunktionen. Wenn die Applikation sich über mehrere Teams verteilt, spielt die Organisation in der Architektur auch eine große Rolle wie wir in dem Kapitel Conways Law gesehen haben. Bei mehreren Teams kann es sein, dass die Microservice Architektur mehr Sinn macht um die Abhängigkeiten der Teams voneinander zu minimieren.

Lassen wir es dabei. Kurz zusammengefasst:

- Aufteilung der Applikation in Frontend und Backend. 
- Das Backend wird mit GO implementiert. Es implementiert Profile und findet geeignete Chatpartner. Wenn ein Chatpartner gefunden ist bekommen diese ein zufälliges Topic zugewiesen mit dem sie über den Message Broker Nachrichten austauschen können. Die Chatverläufe werden nur lokal auf der App gespeichert.
- Datenbanktechnologie wird auf eine document based skalierbare Datebank gesetzt
- Das Frontend wird mit Flutter implementiert um die App nur einmal entwickeln zu müssen

Es gibt immer viele Möglichkeiten eine Software Architektur aufzubauen. Das ist ein kreativer Prozess und lässt sich schlecht standardisieren. Die Patterns sind eine Möglichkeit für bestimmte Probleme ähnliche Lösungen die funktionieren umzusetzen. 

Fazit

Lassen wir es hierbei bewenden. Falls Sie wirklich es bis hierhin geschafft haben, sollten Sie jetzt einen Eindruck von der Software Entwicklung und seiner Komplexität bekommen haben. Vielleicht verstehen Sie bei Ihren Entwicklungsteams etwas mehr und können sogar etwas mitreden, dann hätte dieses Buch seinen Zweck erfüllt. Aber es liegt an Ihnen nicht stehen zu bleiben, sich weiter fortzubilden und am Ball zu bleiben. Das ist Software Entwicklung. Viele der hier genannten Technologien sind in 5 Jahren obsolet. Wenn Sie es in der Macht haben, versuchen Sie sich vor allem mit Agilität auseinander zu setzen und einen Rahmen für Ihre Entwickler in erschaffen, dass diese optimal arbeiten können. Vertrauen Sie Ihren Entwicklern und Product Ownern zu, dass diese gute Lösungen umsetzen. Dann können Sie das Thema Digitalisierung meistern und Ihr Unternehmen auf das nächste Level heben.

Multithreading

1. 
1. Hier wird das ganze Software Entwickeln schon richtig komplex. Nachdem das Betriebssystem der Manager der Hardware ist, muss ein Prozess dieses um Rechenleistung bitten. Das Betriebssystem weist den Programmen Prozessorleistung zu, indem es ca. alle 20ms alle Programme unterbricht das Betriebssystem alle Prozesse durchsucht wer Rechenleistung beantragt hat und entscheidet welches als nächstes die CPU nutzen darf. Somit gaukelt man den Benutzer vor, dass er mehrere Programme gleichzeitig nutzen kann. Das Betriebssystem ruft jetzt nicht direkt die Prozesse auf und sagt: „Prozess A bitte jetzt rechnen“ sondern in einem Prozess laufen mehrere sogenannte Threads. Ein Prozess kann in seinem Programmcode einen Thread starten und in diesem Programmcode laden. Der Thread kümmert sich dann um die Ausführung.
1. 
1. Warum benötigt man so etwas? Sagen wir einfach Sie hätten Software das größere Reportings für ein Unternehmen generieren kann. Das Erstellen der Reportings ist komplex und dauert seine Zeit. Der Nutzer drückt auf den Button, der die Berechnung anstößt. Wenn das Erstellen des Reportings nicht in einen Thread ausgelagert wird, dann friert die Oberfläche ein bis den Report erstellt ist und Sie können nicht weiterarbeiten. Wenn das Generieren des Reports aber in einem extra Thread ausgelagert ist, können Sie in der Oberfläche weiterarbeiten, während ein Ladebalken in der Statusleiste anzeigt, wann der Report fertig ist. Und mit Multicore CPUs hat das Thema noch einmal mehr an Bedeutung gewonnen. Wenn man eine 8 Core CPU hat, können 8 Threads wirklich parallel arbeiten und man kann die Applikation in der Ausführung beschleunigen.

1. Multithreading hat viele Vorzüge aber ist für den Entwickler oft problematisch. Nachdem das OS entscheidet welcher Thread wann ausgeführt wird und das nicht in der Hand des Entwicklers liegt kann es verrückte Effekte und Fehler geben, die zufällig passieren und die man nicht einfach nachstellen kann. Eines der Effekte sind sogenannte Race Conditions, kurz gesagt bedeutet das, dass man ein und dasselbe Programm startet und selten unterschiedliche Ergebnisse bekommt.
1. 
1. Ein Beispiel für eine Race Condition:
1. 
1. Wir wollen ein Integer mit Wert 1 um eins erhöht. Man sagt dazu auch Inkrementieren. Aber der gleiche Code wird in zwei Thread gleichzeitig ausgeführt. Obwohl das in den meisten Programmiersprachen nur eine Zeile Code ist (i++) aber wir haben ja gelernt, dass das in CPU Befehle übersetzt wird. Somit ist ein einfacher inkrement mit dem ++ Operator in Wirklichkeit 3 CPU Befehle.
1. 
1. Lade aus Speicheradresse x in die CPU
1. Erhöhe den Wert um eins
1. Speichere den neuen Wert wieder in x
1. 
1. In der nächsten Abbildung wird der Code ausgeführt wie man das erwarten würde. Zwei Threads laufen erhöhen den Wert jeweils um 1 und es kommt der Wert 3 heraus.
1. 

Abbildung 23 Keine Race Condition

1. In der nächsten Abbildung unterbricht das OS den Thread 1 nachdem der Wert geladen wurde, wechselt zu Thread 2 der jetzt auch den Wert 1 aus dem Speicher liest. Der Wert wird auf 2 erhöht und dann gespeichert. Hier ist der Thread fertig, das OS lässt Thread 1 wieder laufen setzt den Zustand innerhalb der CPU wieder so wie er bei Thread 1 war und Inkrementiert den Wert der geladen wurde, nämlich die 1. Somit haben wir also Endergebnis die zwei obwohl wir zweimal den Wert inkrementiert haben. 
1. 

Abbildung 24 Unerwartetes Ergebnis durch Race Condition

Das nennt man eine Race Condition und man muss sehr stark als Entwickler aufpassen, dass man solche Effekte von vorneherein vermeidet. Diese Fehler nachzuvollziehen bzw. zu debuggen ist sehr schwer. Es gibt auch Möglichkeiten solche Probleme zu verhindern aber wir gehen da nicht tiefer darauf ein.

